# L, C, P = map(int, input().split())
#
# tableau = [list(input()) for i in range(L)]

from pprint import pprint


L, C, P = 2, 3, 10
example = [
    [6, 3, 3],
    [1, 0, 3],
]

L, C, P = 4, 7, 10
example = [
    [-0, 21, -1, -83, 27, 3, 4],
    [2, -10, 60, 6, 11, -20, -27],
    [-12, 100, -2, 2, 9, -12, 80],
    [9, -21, -99, 1, 10, 7, -8],
]

score_creusee_independant = [  # colonne par colonne
    [0 for _ in range(C)] for _ in range(L + 1)
]

score_creusee = [[0 for _ in range(C)] for _ in range(L + 1)]

max_profit_per_column = [0 for _ in range(C + 1)]

meilleur_score_colonne_precedente = 0
meilleure_profondeur_colonne_precedente = 0

for i in range(C):
    for j in range(1, L + 1):
        penalite = P
        score_creusee_independant[j][i] = (
            score_creusee_independant[j - 1][i] + example[j - 1][i] - penalite
        )


for i in range(C):
    score_creusee[0][i] = meilleur_score_colonne_precedente

    meilleur_score_colonne_actuelle = meilleur_score_colonne_precedente
    meilleure_profondeur_colonne_actuelle = 0
    for j in range(1, L + 1):
        penalite = 0

        if j > meilleure_profondeur_colonne_precedente:
            penalite = P

        score_creusee[j][i] = score_creusee[j - 1][i] + example[j - 1][i] - penalite

        # if (
        #     i > 1 and j > meilleure_profondeur_colonne_precedente
        # ):  # on regarde la case à gauche pour éventuellement la prendre et mutualiser
        #     # le coût de creusée
        #     score_avec_case_gauche = (
        #         score_creusee[j - 1][i] + example[j - 1][i] + example[j - 1][i - 1]
        #     )
        #
        #     if score_avec_case_gauche > score_creusee[j][i]:
        #         score_creusee[j][i] = score_avec_case_gauche

        if score_creusee[j][i] > meilleur_score_colonne_actuelle:
            meilleur_score_colonne_actuelle = score_creusee[j][i]
            meilleure_profondeur_colonne_actuelle = j

        print(f"{j = }, ({meilleure_profondeur_colonne_precedente})")

    meilleur_score_colonne_precedente = meilleur_score_colonne_actuelle
    meilleure_profondeur_colonne_precedente = meilleure_profondeur_colonne_actuelle

import numpy as np

print("score_creusee_independant")
print(np.array(score_creusee_independant))
print("score_creusee_independant + P")
print(np.array(score_creusee_independant) + P)
print("score_creusee")
print(np.array(score_creusee))

resultat_attendu = [
    [0, 0, 81, 140, 140, 158, 161],
    [-60, 11, 80, 57, 157, 161, 165],
    [-68, -9, 140, 63, 158, 141, 128],
    [-90, 81, 138, 63, 157, 128, 198],
    [-91, 50, 29, 54, 157, 135, 184],
]
print("vs")
print(np.array(resultat_attendu))


def max_profit(L, C, P, grid):
    # dp[i] - le meilleur profit jusqu'à la ligne i
    dp = [0] * (L + 1)

    # Pour chaque ligne de la grille
    for i in range(1, L + 1):
        current_line = grid[i - 1]

        # On va calculer tous les paliers possibles sur la ligne i-1 (grille est 0-indexée)
        best_for_current_line = float("-inf")

        # On essaie tous les segments possibles dans la ligne actuelle
        for start in range(C):
            sum_segment = 0  # somme des valeurs du segment
            for end in range(start, C):
                sum_segment += current_line[end]

                # Profit du segment
                profit = sum_segment - P

                # On met à jour le meilleur profit prenant en compte les paliers précédents
                best_for_current_line = max(best_for_current_line, dp[i - 1] + profit)

        # On met à jour le profit maximum jusqu'à la ligne i
        dp[i] = max(dp[i - 1], best_for_current_line)

    return dp[L]


# Calcul du meilleur profit
result = max_profit(L, C, P, example)
print(f"{result = }")
