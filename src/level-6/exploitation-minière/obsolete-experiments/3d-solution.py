import matplotlib
import matplotlib.pyplot as plt
import networkx as nx
import sys
from src.utils.input import define_string_as_input

input_string = """2 3 10
100 5 100
-100 -100 -100"""

input_string = """4 7 10
-50 21 -1 -83 27 3 4
2 -10 60 6 11 -20 -27
-12 100 -2 2 9 -12 80
9 -21 -99 1 10 7 -8"""

define_string_as_input(input_string)

# ---------- Constantes ----------
L = 4
C = 7
INCONNU = 500 * 500 * 100 + 1

# ---------- Variables ----------
profit_dyn = [[[INCONNU for _ in range(L)] for _ in range(C)] for _ in range(C)]
minerai = [[0 for _ in range(C)] for _ in range(L)]

nb_lignes = 0
nb_colonnes = 0
pallier = 0

# Pour enregistrer les appels récursifs
appel_recursif = []
id_counter = 0


# ---------- Fonctions ----------
def meilleur_profit(debut, fin, ligne, parent=None):
    """
    Renvoie le meilleur profit entre la colonne 'debut' et 'fin' (inclus),
    à la ligne 'ligne'.

    Deux options :
    1) Découper le sous-problème en sous-parties.
    2) Prendre la somme de tous les minerais entre [debut; fin] moins le pallier.
    """
    global profit_dyn, id_counter, appel_recursif

    current_id = id_counter
    id_counter += 1

    appel_recursif.append(
        (current_id, parent, debut, fin, ligne))  # Enregistrer l'appel

    if profit_dyn[debut][fin][ligne] == INCONNU:  # Diviser pour régner
        profit_max = 0

        # ----- 1) Découpage -----
        for i in range(debut, fin):
            profit = meilleur_profit(debut, i, ligne, current_id) + meilleur_profit(
                i + 1, fin, ligne, current_id)
            profit_max = max(profit_max, profit)

        # ----- 2) On prend tout -----
        profit = 0
        for i in range(debut, fin + 1):
            profit += minerai[ligne][i]

        profit -= pallier  # On enlève le prix du pallier

        if ligne < nb_lignes - 1:  # On recommence pour la ligne suivante
            profit += meilleur_profit(debut, fin, ligne + 1, current_id)

        profit_max = max(profit_max, profit)

        # Mise à jour du tableau dynamique
        profit_dyn[debut][fin][ligne] = profit_max

    return profit_dyn[debut][fin][ligne]


# Fonction pour afficher le graphe des appels récursifs
def affiche_appels():
    print("ID | Parent | Debut | Fin | Ligne")
    for appel in appel_recursif:
        print(
            f"{appel[0]}  |   {appel[1]}   |   {appel[2]}   |   {appel[3]}   |   {appel[4]}")

    print("\nStructure d'arbre (ID -> Parent ID):")
    for appel in appel_recursif:
        if appel[1] is not None:
            print(f"{appel[0]} -> {appel[1]}")


# ---------- Main ----------
if __name__ == "__main__":
    # -------- Lecture des entrées --------
    nb_lignes, nb_colonnes, pallier = map(int, input().split())

    for i in range(nb_lignes):
        minerai[i] = list(map(int, input().split()))

    # -------- Initialisation --------
    for i in range(C):
        for j in range(i, C):
            for k in range(L):
                profit_dyn[i][j][k] = INCONNU

    for i in range(nb_colonnes):
        # Cas d'arrêt : profit_dyn[i][i][nb_lignes-1] = minerai[nb_lignes-1][i] -
        # pallier
        profit_dyn[i][i][nb_lignes - 1] = max(0, minerai[nb_lignes - 1][i] - pallier)

    # -------- Calcul du résultat --------
    resultat = meilleur_profit(0, nb_colonnes - 1, 0)

    # -------- Affichage du résultat --------
    print(resultat)



def creer_arbre_appels(liste_appels: list) -> tuple[list[list[int]], list[str]]:
    liste_adjacence: list[list[int]] = []
    labels = []
    for node in liste_appels:
        node_id, parent, debut, fin, ligne = node
        labels.append(f"{debut} | {fin} | {ligne}")

        if parent is None:
            liste_adjacence.append([])
        else:
            liste_adjacence.append([parent])

    return liste_adjacence, labels


def affiche_arbre_appels(liste_adjacence: list[list[int]], labels: list[str]) -> None:
    tree = nx.DiGraph()

    # Ajouter des arêtes au graphe à partir de la liste d'adjacence
    for i, adj in enumerate(liste_adjacence):
        for node in adj:
            tree.add_edge(node, i)
    pos = nx.spring_layout(tree, seed=3113794652)
    nx.draw_networkx_edges(tree, pos)
    # nx.draw_networkx_labels(tree, pos, labels)
    # plt.tight_layout()
    plt.axis("off")
    plt.show()

